# CHAPTER6 : 예측 가능한 코드를 작성하라

- 코드가 어떻게 예측을 벗어나 작동할 수 있는지
- 소프트웨어에서 예측을 벗어나는 코드가 어떻게 버그로 이어질 수 있는지
- 코드가 예측을 벗어나지 않도록 보장하는 방법

#### 6.1 매직값을 반환하지 말아야 한다.

- 매직값의 일반적인 예는 값이 없거나 오류가 발생했음을 나타내기 위해 **-1**을 반환하는것을 뜻한다.

1. 매직값은 버그를 유발할 수 있다.
   ````java
   class User{
        private Integer age;
        
        private Integer getAge(){
            if(age == null) return  -1;
            return age;
        }
   }
   ````
2. 해결책 : 널, 옵셔널 또는 오류를 반환하라
3. 때때로 매직값이 우연히 발생할 수 있다.

#### 6.2 널 객체 패턴을 적절히 사용하라

- 오류 처리 이외의 경우에 널 객체 패턴을 사용하면 유용하지만, 부적절하게 사용되면 예측을 벗어나는 동작을 할 수 있음.

1. 빈 컬렉션을 반환하면 코드가 개선될 수 있다.
   ````java
   #bad
   Set<String> getClassNames(HtmlElement element){
        if(element == null) return null;
        ...
   }
   
   #good
   Set<String> getClassNames(HtmlElement element){
        if(element == null) return new Set();
        ...
   }
   ````
2. 빈 문자열을 반환하는 것도 때로는 문제가 될 수 있다.
   ````java
   #bad : 거래정보가 없는데도 빈 ""를 리턴함.
   class Payment{
        private final String tid;
        
        public String getTid(){
            if(tid == null) return "";
            return tid;
        }
   }
   
   #good : 거래정보가 없을수도 있음을 명시적으로 작성
   class Payment{
        private final String tid;
        public Optional<String> getTid(){
            return Optional.of(tid);
        }
    }
   ````
3. 더 복잡한 널 객체는 예측을 벗어날 수 있다.
   ````java
   class CoffeeMug{
        CoffeeMug(Double diameter, Double height) {...}
   }
   
   #사용
   CoffeeMug coffeeMug = new CoffeeMug(0,0); //사이즈가 0인 커피머그는 존재하지 않는다.
   - 사이즈가 0인 커피를 만들때는, 객체 생성이 안되도록 null 을 반환하는것이 나을수도 있다.
   ````
4. 널 객체 구현은 예상을 벗어나는 동작을 유발할 수 있다.

#### 6.3 예상치 못한 부수 효과(side effect)를 피하라

1. 분명하고 의도적인 부수 효과는 괜찮다.
2. 예기치 않은 부수 효과는 문제가 될 수 있다.
3. 해결책: 부수효과를 피하거나 그 사실을 분명하게 하라

#### 6.4 입력 매개변수를 수정하는 것에 주의하라

1. 입력 매개변수를 수정하면 버그를 초래할 수 있다.
   ````java
   #bad : 타 메서드등에서 usersWithFreeTrial 을 사용할수 있음. 지워버리면 버그 유발
   List<Invoice> getBillableInvoices(
        Map<User, Invoice> userInvoice,
        Set<User> usersWithFreeTrial
   ){
        userInvoice.removeAll(usersWithFreeTrial);
        return userInvoice;
   }
   #good : 값을 복사하고 처리한다.
   List<Invoice> getBillableInvoices(
        Map<User, Invoice> userInvoice,
        Set<User> usersWithFreeTrial
   ){
        return userInvoice.entries()
            .filter(entry -> !usersWithFreeTrial.contains(entry.getKey()))
            .map(entry -> entry.getVluae());
   }
   ````
2. 해결책: 변경하기 전에 복사하라
   ````java
   #good : 값을 복사하고 처리한다.
   List<Invoice> getBillableInvoices(
        Map<User, Invoice> userInvoice,
        Set<User> usersWithFreeTrial
   ){
        return userInvoice.entries()
            .filter(entry -> !usersWithFreeTrial.contains(entry.getKey()))
            .map(entry -> entry.getVluae());
   }
   ````

#### 6.5 오해를 일으키는 함수는 작성하지 말라

#### 6.6 미래를 대비한 열거형 처리

#### 6.7 이 모든 것을 테스트로 해결할 수는 없는가?


