# CHAPTER4 : 오류

- 시스템이 복구할 수 있는 오류와 복구할 수 없는 오류의 구분
- 신속하게 실패하고 분명하게 실패함
- 오류를 전달하기 위한 다양한 기법과 선택을 위한 고려 사항

#### 4.1 복구 가능성

- 복구할수 있는 오류와 복구할수 없는 오류를 구별 해야한다.
- 복구 가능한 오류
    - 네트워크 오류
    - 중요하지 않은 작업 오류
- 복구할 수 없는 오류
    - 개발자가 개발한 코드의 어느 부분에서 오류를 내뿜는것
- 호출하는 쪽에서만 오류 복구 가능 여부를 알 때가 많다.
- 호출하는 쪽에서 복구하고자 하는 오류에 대해 인지하도록 하라.

#### 4.2 견고성 vs 실패

- 오류가 발생할 때, 다음 중하나를 선택
    - 실패 : 전체 프로그램의 동작을 멈추도록 구현한다.
    - 오류를 처리하고 프로그램을 계속 진행시킨다.

1. 신속하게 실패해라
    - 가능한 한 문제의 실제 발생 지점으로부터 가까운 곳에서 오류를 나타내는 것.
    - 복구할 수 있는 오류의 경우 호출하는 쪽에서 오류로부터 훌륭하고 안전하게 복구할 수 있는 기회를 최대한 제공
    - 복구할 수 없는 오류의 경우 신속하게 문제를 파악할수 있게 해주는 기회를 제공(호출 stacktrace 를 여러뎁스로 확인하기가 힘들다 )
2. 요란하게 실패하라
    - 복구할 수 없는 오류가 발생하는 원인은 대부분 프로그래밍 오류 또는 개발자의 실수 이다.
    - 예외를 통해 프로그램을 중단하게 만든다.
3. 복구 가능성 범위
    - 오류를 알아차리지 못한 채 시스템이 계속 동작하지 않도록 하는 것 또한 중요하기 때문에, 요란하게 실패해야 한다.
    - 한 번의 잘못된 요청으로 인해 전체 서버의 동작이 멈추는 것 또한 바람직하지 않다.
4. 오류를 숨기지 않음
    - 오류가 발생하면 알리는 것이 좋다.

#### 4.3 오류 전달 방법

- 오류가 발생하면 일반적으로 더 높은 계층으로 오류를 알려야 한다.
- 오류를 알리는 방법
    - 명시적 방법
        - 코드를 직접 호출한 쪽에서 오류가 발생할 수 있음을 인지할 수밖에 없도록 강제한다.
    - 암시적 방법
        - 코드를 호출하는 쪽에 오류를 알리지만, 호출하는 쪽에서 그 오류를 신경 쓰지 않아도 된다.

1. 요약 : 예외
    - 자바는 검사 예외(checked exception) 와 비검사 예외(unchecked exception)의 개념을 모두 가지고 있다.
2. 명시적 방법 : 검사 예외

- 검사 예외를 사용하는 것은 오류를 전달하기 위한 명시적인 방법이다.
    ````java
     class NegativeNumberException extends Exception{//검사 예외의 구체적인 예제 Exception
        private final Double erroneousNumber;
        
        NegativeNumberException(Double erroneousNumber){
            this.erroneousNumber = erroneousNumber;
        }
     }
     
     //사용
     Double getSquareRoot(Double value) throws NegativeNumberException{//검사예외
        if(value < 0.0){
            throw new NegativeNumberException(value);//오류발생시 검사예외 발생시킴
        }
        return Math.sqrt(value); 
     }
     ````

3. 암시적 방법 : 비검사 예외

- 비검사 예외를 사용한 오류 전달
    ````java
     class NegativeNumberException extends RuntimeException{//비검사 예외의 구체적인 예제 RuntimeException
        private final Double erroneousNumber;
        
        NegativeNumberException(Double erroneousNumber){
            this.erroneousNumber = erroneousNumber;
        }
     }
     
     //사용
     Double getSquareRoot(Double value){
        if(value < 0.0){
            throw new NegativeNumberException(value);//오류발생시 비검사예외 발생시킴
        }
        return Math.sqrt(value); 
     }
     ````

4. 명시적 방법 : 널값이 가능한 반환 유형

- 널값을 이용하여 오류를 전달한다.
- 호출부에서 널값을 확인하여, 오류를 판단한다.

5. 명시적 방법 : 리절트 반환 유형

- 호출부에 값을 얻을 수 없는 이유를 알려준다.
- 물론 리절트 유형을 지원하지 않는 언어에서는 사용하는 것이 번거로울 수 있다.

6. 명시적 방법 : 아웃컴 반환유형
    ````java
    @CheckReturnValue //호출하는 쪽에서 함수의 반환값을 무시하면 안된다는것을 나타낸다.
    Boolean sendMessage(Channel channel, String messgage){
        ...
    }
    ````

7. 암시적 방법 : 프로미스 또는 퓨처

- 호출하는 쪽에서는 잠재적인 오류 시나리오를 완전히 알지 못하기 때문에, 프로미스나 퓨처를 사용하는 것은
  오류를 알리는 암시적인 방법이 된다.

8. 암시적 방법 : 매직값 반환

- 매직값은 함수의 정상적인 반환 유형에 적합하지만 특별한 의미를 부여하는 값이다.
    - 만약 오류가 발생하면 -1을 리턴한다 등이 예이다.
    - 좋은 방법은 아니다.

#### 4.4 복구할 수 없는 오류의 전달

- 복구할 가능성이 없는 오류가 발생하면 신속하게 실패하고, 요란하게 실패하는 것이 최상의 방법이다.

#### 4.5 호출하는 쪽에서 복구하기를 원할 수도 있는 오류의 전달

- 오류 처리에 대한 여러 사람들의 관점 (틀린 것이 없다. 팀에 맞춰라)

1. 비검사 예뢰를 사용해야 한다는 주장
    - 코드 구조 개선 : 오류가 높은 계층까지 거슬러 올라오면서 코드 구조를 개선할 수 있다고 주장
    - 명시오류로 잡으면 타고타고 가면서 다 익셉션을 전파하도록 해야함.
2. 명시적 기법을 사용해야 한다는 주장
    - 매끄러운 오류처리 : 오류를 매끄럽게 처리할 수 있는 단일 계층을 갖기가 어럅다.
    - 실수로 오류를 무시할 수 없다.

- 비검사 예외를 사용하는 개발자가 선호하는 방식은 ArgumentException 이나 StateException 과 같은
  표준 예외 유형혹은 그것들의 서브클래스를 사용한다.

**비검사 예외건 명시적 기법이건 두개다 장단점이 있다.**

3. 필자의 의견 : 명시적 방식을 사용해라
    - 호출하는 쪽에서 복구하기를 원할 수도 있는 오류에 대해 비검사 예외를 사용하지 않는 것이 최상이다.
    - 하지만, 팀원들이 오류 전달에 대한 철학에 동의하고 그것을 따르는 것이 가장 바람직한다.

#### 4.6 컴파일러 경고를 무시하지 말라

- 컴파일할 때 경고가 없는 것이 이상적이다.

### 요약

- 오류는 크게 두가지 종류이다.
    - 시스템이 복구할 수 있는 오류
    - 시스템이 복구할 수 없는 오류
- 오류가 발생하면 신속하게 실패하는 것이 좋고, 에러를 복구할 수 없는 경우에는 요란하게 실패하는것이 바람직하다.
- 오류를 숨기는 것은 대부분 바람직하지 않을 때가 많으므로, 오류가 발생했다는 신호를 내보내는 것이 바람직하다.
- 오류 전달 기법은 두 가지 범주로 나눌 수있다.
    - 명시적 방법 : 호출하는 쪽에서 오류가 발생할 수 있음을 인지
    - 암시적 방법 : 코드 계약의 세부 조항을 통해 오류에 대한 설명이 제공되거나 전혀 설명이 없을 수도 있다.
- 복구할 수 없는 오류에 대해서는 암시적 오류 전달 기법을 사용해야 한다.

